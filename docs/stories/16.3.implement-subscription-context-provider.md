# Story 16.3: Implement Subscription Context Provider

## Status
Pending

## Story
**As a** frontend developer,  
**I want** a React Context provider that manages subscription state,  
**so that** components can easily access subscription status and premium feature permissions.

## Acceptance Criteria
1. SubscriptionContext integrates with existing DataContext caching system
2. useSubscription hook provides subscription status and premium status
3. usePremiumFeature hook provides feature-specific access control
4. Context provider handles loading states and error scenarios gracefully
5. Subscription state updates automatically when webhook events occur
6. Type-safe interfaces for all subscription-related data

## Tasks / Subtasks
- [ ] Create SubscriptionContext provider (AC: 1)
  - [ ] Integrate with existing DataContext for subscription data
  - [ ] Leverage 5-minute cache cycle for subscription status
  - [ ] Wrap existing context hierarchy without breaking patterns
  - [ ] Handle subscription data as part of unified data fetch
- [ ] Implement useSubscription hook (AC: 2)
  - [ ] Return current subscription status (free, active, cancelled, etc.)
  - [ ] Provide isPremium computed boolean for quick access
  - [ ] Include subscription metadata (plan_id, billing dates, etc.)
  - [ ] Handle loading and error states from DataContext
  - [ ] Provide refresh function for manual subscription sync
- [ ] Implement usePremiumFeature hook (AC: 3)
  - [ ] Accept feature key parameter for specific feature checks
  - [ ] Return hasAccess boolean for feature availability
  - [ ] Provide upgrade prompts and messaging for locked features
  - [ ] Cache feature access decisions to prevent repeated calculations
  - [ ] Support feature preview mode for free users
- [ ] Add comprehensive error handling (AC: 4)
  - [ ] Graceful degradation when subscription service unavailable
  - [ ] Error boundaries for subscription-related components
  - [ ] Fallback states that don't break existing functionality
  - [ ] User-friendly error messages for subscription issues
- [ ] Implement real-time subscription updates (AC: 5)
  - [ ] Listen for DataContext cache invalidation events
  - [ ] Automatic re-fetch when subscription status changes
  - [ ] Optimistic updates for subscription actions
  - [ ] Rollback mechanism for failed subscription changes
- [ ] Create TypeScript interfaces (AC: 6)
  - [ ] Define SubscriptionContextData interface
  - [ ] Create FeatureAccess type definitions
  - [ ] Export subscription-related types for component usage
  - [ ] Ensure type safety across subscription flows

## Dev Notes

### Architecture References
Based on the sharded architecture document:
- **Frontend Architecture**: `docs/lemonsqueezy-subscription-architecture/frontend-architecture.md`
- **Components**: `docs/lemonsqueezy-subscription-architecture/components.md` (SubscriptionContext)
- **Data Models**: `docs/lemonsqueezy-subscription-architecture/data-models.md`

### Context Provider Implementation

#### File Structure
```
src/
├── contexts/
│   └── SubscriptionProvider.tsx    # New subscription context
├── hooks/
│   ├── useSubscription.ts          # Subscription status hook
│   └── usePremiumFeature.ts        # Feature access hook
└── types/
    └── subscription.ts             # Subscription type definitions
```

#### Integration with DataContext
```typescript
interface ExtendedDataState {
  // Existing data fields
  user: User;
  flockProfiles: FlockProfile[];
  eggEntries: EggEntry[];
  
  // New subscription data (cached together)
  subscription: SubscriptionStatus;
  features: Record<string, FeatureAccess>;
}
```

### Hook Specifications

#### useSubscription Hook
```typescript
export const useSubscription = () => {
  const { data, isLoading, error } = useContext(DataContext);
  
  return {
    subscription: data?.subscription,
    isPremium: data?.subscription?.status === 'active',
    isLoading,
    error,
    refresh: () => data?.refresh?.(),
  };
};
```

#### usePremiumFeature Hook
```typescript
export const usePremiumFeature = (featureKey: string) => {
  const { data } = useContext(DataContext);
  const featureAccess = data?.features?.[featureKey];
  
  return {
    hasAccess: featureAccess?.has_access ?? false,
    requiresUpgrade: featureAccess?.requires_upgrade ?? true,
    featureName: featureAccess?.feature_name ?? featureKey,
    upgradePrompt: featureAccess?.upgrade_prompt,
  };
};
```

### TypeScript Interfaces

#### Core Subscription Types
```typescript
interface SubscriptionStatus {
  status: 'free' | 'active' | 'cancelled' | 'past_due' | 'paused';
  isPremium: boolean;
  subscriptionId?: string;
  planId?: string;
  billingEmail?: string;
  subscriptionStartDate?: string;
  subscriptionEndDate?: string;
  nextBillingDate?: string;
}

interface FeatureAccess {
  hasAccess: boolean;
  requiresUpgrade: boolean;
  featureName: string;
  upgradePrompt?: string;
}
```

### Integration Points
- **DataContext**: Subscription data flows through existing cache system
- **AuthContext**: User authentication state for subscription association
- **API Service**: Subscription endpoints for status and feature access
- **Error Boundaries**: Graceful handling of subscription service failures

### Performance Considerations
- **Caching**: Leverages existing 5-minute DataContext cache cycle
- **Computed Values**: isPremium calculated once and cached
- **Feature Gates**: Feature access decisions cached to prevent recalculation
- **Memory**: Minimal additional state beyond existing DataContext

### Testing Requirements
- Unit tests for both hooks with various subscription states
- Integration tests with DataContext caching behavior
- Error scenario tests (network failures, invalid data)
- Feature access permission tests for all premium features
- Loading state and error boundary tests

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-30 | 1.0 | Initial story creation for subscription context provider | Winston (Architect) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*